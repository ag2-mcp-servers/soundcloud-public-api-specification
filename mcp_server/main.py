# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:31:09+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, APIKeyQuery, BaseSecurity
from fastapi import UploadFile
from pydantic import conint
from starlette.requests import Request

from models import (
    Access1,
    Access2,
    Access3,
    Access4,
    Access5,
    Access6,
    Access7,
    Access8,
    Access9,
    Access10,
    Access11,
    Access12,
    Activities,
    Bpm,
    Comment,
    CommentsList,
    CompleteUser,
    Connection,
    Connections,
    CreatedAt,
    CreateUpdatePlaylistRequest,
    Duration,
    Error,
    Found,
    MeFollowersGetResponse,
    MeFollowingsGetResponse,
    MeLikesTracksGetResponse,
    MetaUsers,
    MeTracksGetResponse,
    Oauth2TokenPostResponse,
    Playlist,
    PlaylistsArray,
    PlaylistsGetResponse,
    PlaylistsPlaylistIdPutResponse,
    PlaylistsPlaylistIdTracksGetResponse,
    PlaylistsPostResponse,
    ResponseType,
    Streams,
    TooManyRequests,
    Track,
    TrackMetadataRequest,
    TracksGetResponse,
    TracksList,
    TracksTrackIdCommentsGetResponse,
    TracksTrackIdRelatedGetResponse,
    User1,
    UsersGetResponse,
    UsersList,
    UsersUserIdFavoritesGetResponse,
    UsersUserIdFollowersGetResponse,
    UsersUserIdFollowingsGetResponse,
    UsersUserIdLikesTracksGetResponse,
    UsersUserIdPlaylistsGetResponse,
    UsersUserIdTracksGetResponse,
    WebProfiles,
)

app = MCPProxy(
    contact={'name': 'API issue tracker', 'url': 'https://github.com/soundcloud/api'},
    termsOfService='https://developers.soundcloud.com/docs/api/terms-of-use',
    title='SoundCloud Public API Specification',
    version='1.0.0',
    servers=[{'url': 'https://api.soundcloud.com'}],
)


@app.get(
    '/connect',
    description=""" <h3>Security Advice</h3>
* Using the [implicit OAuth authorization flow](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16#section-2.1.2) (`response_type=token`)  is **not recommended**. It can suffer from access token leakage and access token replay attacks. Use `response_type=code` instead.
* Use the `state` parameter for [CSRF protection](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16#section-4.7). Pass a sufficient  random nonce here and verify this nonce again after retrieving the token.
 """,
    tags=['user_authentication', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_connect(
    client_id: str,
    redirect_uri: str = ...,
    response_type: ResponseType = ...,
    scope: str = ...,
    state: Optional[str] = None,
):
    """
    The OAuth2 authorization endpoint. Your app redirects a user to this endpoint, allowing them to delegate access to their account.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/likes/playlists/{playlist_id}',
    tags=['playlist_operations', 'user_relationship_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_likes_playlists__playlist_id(playlist_id: int):
    """
    Unlikes a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/likes/playlists/{playlist_id}',
    tags=['playlist_operations', 'user_activity_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def post_likes_playlists__playlist_id(playlist_id: int):
    """
    Likes a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/likes/tracks/{track_id}',
    tags=['user_activity_tracking', 'user_relationship_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_likes_tracks__track_id(track_id: int):
    """
    Unlikes a track.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/likes/tracks/{track_id}',
    tags=['user_activity_tracking', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def post_likes_tracks__track_id(track_id: int):
    """
    Likes a track.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me',
    tags=['user_authentication', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me():
    """
    Returns the authenticated user’s information.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/activities',
    tags=['user_activity_tracking', 'user_authentication'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_activities(
    access: Optional[Access1] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
):
    """
    Returns the authenticated user's activities.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/activities/all/own',
    tags=['user_activity_tracking', 'user_authentication'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_activities_all_own(
    access: Optional[Access2] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
):
    """
    Recent the authenticated user's activities.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/activities/tracks',
    tags=['user_activity_tracking', 'user_authentication'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_activities_tracks(
    access: Optional[Access3] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
):
    """
    Returns the authenticated user's recent track related activities.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/connections',
    tags=['user_authentication', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_connections(
    limit: Optional[conint(ge=1, le=200)] = 50, offset: Optional[int] = 0
):
    """
    Returns a list of the authenticated user's connected social accounts.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/connections/{connection_id}',
    tags=['user_authentication', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_connections__connection_id(connection_id: int):
    """
    Returns the authenticated user's connected social account.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/favorites/ids',
    tags=['user_activity_tracking', 'user_account_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_favorites_ids(limit: Optional[conint(ge=1, le=200)] = 50):
    """
    Returns user’s favorites ids. (use /me/likes/tracks instead to fetch the authenticated user's likes)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/followers',
    tags=[
        'user_relationship_management',
        'user_activity_tracking',
        'user_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_followers(limit: Optional[conint(ge=1, le=200)] = 50):
    """
    Returns a list of users who are following the authenticated user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/followers/{follower_id}',
    tags=['user_relationship_management', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_followers__follower_id(follower_id: int):
    """
    Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/followings',
    tags=[
        'user_relationship_management',
        'user_activity_tracking',
        'user_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_followings(
    limit: Optional[conint(ge=1, le=200)] = 50, offset: Optional[int] = 0
):
    """
    Returns a list of users who are followed by the authenticated user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/followings/tracks',
    tags=['user_activity_tracking', 'user_relationship_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_followings_tracks(
    access: Optional[Access4] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    offset: Optional[int] = 0,
):
    """
    Returns a list of recent tracks from users followed by the authenticated user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/followings/{user_id}',
    tags=['user_relationship_management', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_me_followings__user_id(user_id: int):
    """
    Deletes a user who is followed by the authenticated user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/followings/{user_id}',
    tags=['user_relationship_management', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_followings__user_id(user_id: int):
    """
    Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/me/followings/{user_id}',
    tags=['user_relationship_management', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_me_followings__user_id(user_id: int):
    """
    Follows a user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/likes/tracks',
    tags=['user_activity_tracking', 'user_account_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_likes_tracks(
    limit: Optional[conint(ge=1, le=200)] = 50,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns a list of favorited or liked tracks of the authenticated user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/playlists',
    description=""" Returns playlist info, playlist tracks and tracks owner info. """,
    tags=['playlist_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_playlists(limit: Optional[conint(ge=1, le=200)] = 50):
    """
    Returns user’s playlists (sets).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/playlists/{playlist_id}',
    tags=['playlist_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_playlists__playlist_id(playlist_id: int):
    """
    Returns playlist. (use /playlists/{playlist_id} instead, to fetch the playlist details)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/tracks',
    tags=['user_activity_tracking', 'user_account_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_tracks(
    limit: Optional[conint(ge=1, le=200)] = 50,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns a list of user's tracks.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/tracks/{track_id}',
    tags=['track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_me_tracks__track_id(track_id: int):
    """
    Returns a specified track. (use /tracks/{track_id} instead, to fetch the track details)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/oauth2/token',
    tags=['user_authentication'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def post_oauth2_token(request: Request):
    """
    This endpoint accepts POST requests and is used to provision access tokens once a user has authorized your application.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists',
    tags=['playlist_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_playlists(
    q: str,
    access: Optional[Access5] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    offset: Optional[int] = 0,
    linked_partitioning: Optional[bool] = None,
):
    """
    Performs a playlist search based on a query
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/playlists',
    tags=['playlist_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def post_playlists(body: CreateUpdatePlaylistRequest = None):
    """
    Creates a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/playlists/{playlist_id}',
    tags=['playlist_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def delete_playlists__playlist_id(playlist_id: int):
    """
    Deletes a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}',
    tags=['playlist_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_playlists__playlist_id(
    playlist_id: int,
    secret_token: Optional[str] = None,
    access: Optional[Access6] = 'playable,preview',
):
    """
    Returns a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/playlists/{playlist_id}',
    tags=['playlist_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_playlists__playlist_id(
    playlist_id: int, body: CreateUpdatePlaylistRequest = None
):
    """
    Updates a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}/reposters',
    tags=['playlist_operations', 'user_activity_tracking'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_playlists__playlist_id_reposters(
    playlist_id: int, limit: Optional[conint(ge=1, le=200)] = 50
):
    """
    Returns a collection of playlist's reposters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/playlists/{playlist_id}/tracks',
    tags=['playlist_operations', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_playlists__playlist_id_tracks(
    playlist_id: int,
    secret_token: Optional[str] = None,
    access: Optional[Access7] = 'playable,preview',
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns tracks under a playlist.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/reposts/playlists/{playlist_id}',
    tags=['playlist_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_reposts_playlists__playlist_id(playlist_id: int):
    """
    Removes a repost on a playlist as the authenticated user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reposts/playlists/{playlist_id}',
    tags=['playlist_operations', 'user_activity_tracking', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def post_reposts_playlists__playlist_id(playlist_id: int):
    """
    Reposts a playlist as the authenticated user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/reposts/tracks/{track_id}',
    tags=['track_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_reposts_tracks__track_id(track_id: int):
    """
    Removes a repost on a track as the authenticated user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reposts/tracks/{track_id}',
    tags=['user_activity_tracking', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def post_reposts_tracks__track_id(track_id: int):
    """
    Reposts a track as the authenticated user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resolve',
    tags=['url_conversion'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_resolve(url: str):
    """
    Resolves soundcloud.com URLs to Resource URLs to use with the API.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks',
    tags=['track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks(
    q: str,
    ids: Optional[str] = None,
    genres: Optional[str] = None,
    tags: Optional[str] = None,
    bpm: Optional[Bpm] = None,
    duration: Optional[Duration] = None,
    created_at: Optional[CreatedAt] = None,
    access: Optional[Access8] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    offset: Optional[int] = 0,
    linked_partitioning: Optional[bool] = None,
):
    """
    Performs a track search based on a query
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tracks',
    tags=['track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def post_tracks(file: UploadFile):
    """
    Uploads a new track.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tracks/{track_id}',
    tags=['track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_tracks__track_id(track_id: int):
    """
    Deletes a track.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{track_id}',
    tags=['track_operations'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks__track_id(track_id: int, secret_token: Optional[str] = None):
    """
    Returns a track.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/tracks/{track_id}',
    tags=['track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_tracks__track_id(track_id: int, body: TrackMetadataRequest = None):
    """
    Updates a track's information.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{track_id}/comments',
    tags=['track_operations'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks__track_id_comments(
    track_id: int,
    limit: Optional[conint(ge=1, le=200)] = 50,
    offset: Optional[int] = 0,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns the comments posted on the track(track_id).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tracks/{track_id}/comments',
    tags=['track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def post_tracks__track_id_comments(track_id: int):
    """
    Returns the newly created comment on success
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{track_id}/favoriters',
    tags=['user_activity_tracking', 'track_operations', 'user_account_management'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks__track_id_favoriters(
    track_id: int, limit: Optional[conint(ge=1, le=200)] = 50, offset: Optional[int] = 0
):
    """
    Returns a list of users who have favorited or liked the track.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{track_id}/related',
    tags=['track_operations'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks__track_id_related(
    track_id: int,
    access: Optional[Access9] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    offset: Optional[int] = 0,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns all related tracks of track on SoundCloud.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{track_id}/reposters',
    tags=['track_operations', 'user_relationship_management'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks__track_id_reposters(
    track_id: int, limit: Optional[conint(ge=1, le=200)] = 50
):
    """
    Returns a collection of track's reposters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tracks/{track_id}/streams',
    tags=['track_operations'],
    security=[
        APIKeyQuery(name="client_id"),
    ],
)
def get_tracks__track_id_streams(track_id: int, secret_token: Optional[str] = None):
    """
    Returns a track's streamable URLs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    tags=['user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users(
    q: str,
    ids: Optional[str] = None,
    limit: Optional[conint(ge=1, le=200)] = 50,
    offset: Optional[int] = 0,
    linked_partitioning: Optional[bool] = None,
):
    """
    Performs a user search based on a query
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}',
    tags=['user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id(user_id: int):
    """
    Returns a user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/comments',
    tags=['user_activity_tracking', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_comments(
    user_id: int, limit: Optional[conint(ge=1, le=200)] = 50, offset: Optional[int] = 0
):
    """
    Returns a list of user's comments.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/favorites',
    tags=['user_activity_tracking', 'user_account_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_favorites(
    user_id: int,
    limit: Optional[conint(ge=1, le=200)] = 50,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns a list of user's favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user's likes)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/followers',
    description=""" Returns a list of users that follows (user_id). """,
    tags=['user_relationship_management', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_followers(
    user_id: int, limit: Optional[conint(ge=1, le=200)] = 50
):
    """
    Returns a list of user’s followers.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/followings',
    description=""" Returns list of users that (user_id) follows. """,
    tags=[
        'user_relationship_management',
        'user_activity_tracking',
        'user_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_followings(
    user_id: int, limit: Optional[conint(ge=1, le=200)] = 50
):
    """
    Returns a list of user’s followings.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/followings/{following_id}',
    description=""" Returns (following_id) that is followed by (user_id). """,
    tags=['user_relationship_management', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_followings__following_id(user_id: int, following_id: int = ...):
    """
    Returns a user's following. (use /users/{user_id} instead, to fetch the user details)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/likes/tracks',
    tags=['user_activity_tracking', 'user_account_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_likes_tracks(
    user_id: int,
    access: Optional[Access10] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns a list of user's liked tracks.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/playlists',
    tags=['playlist_operations', 'user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_playlists(
    user_id: int,
    access: Optional[Access11] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns a list of user's playlists.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/tracks',
    tags=['user_activity_tracking', 'user_account_management', 'track_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_tracks(
    user_id: int,
    access: Optional[Access12] = 'playable,preview',
    limit: Optional[conint(ge=1, le=200)] = 50,
    linked_partitioning: Optional[bool] = None,
):
    """
    Returns a list of user's tracks.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user_id}/web-profiles',
    tags=['user_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyQuery(name="client_id"),
    ],
)
def get_users__user_id_web_profiles(
    user_id: int, limit: Optional[conint(ge=1, le=200)] = 50
):
    """
    Returns list of user's links added to their profile (website, facebook, instagram).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
